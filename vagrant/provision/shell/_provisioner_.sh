#!/bin/bash


# === DO NOT EDIT THIS FILE ===========================================================================================

prepare() {
    MAIN_FILE='/vagrant/vagrant/provision/shell/main.sh'
    [[ -f "$MAIN_FILE" ]] \
        && source "$MAIN_FILE"

    TMP_NAME="$(mktemp -u 'XXXXXXXXXX')"
    SHM_NAME="/dev/shm/vagrant_provision_${TMP_NAME}')"
    SHM_STDOUT="$SHM_NAME.stdout"
    SHM_STDERR="$SHM_NAME.stderr"
    TMP="/tmp/vagrant.${TMP_NAME}";

    if [[ "$(type -t main)" != 'function' ]]; then
        echo ' ' >&2
        echo 'Main provisioning file is missing!' >&2
        echo "Please create the file '{vm_dir}/config/provision/shell/main.sh' with at leaset a 'main' function:" >&2
        echo ' ' >&2
        echo '    # main.sh' >&2
        echo ' ' >&2
        echo '    main() {' >&2
        echo "        echo 'do provisioning stuff here'" >&2
        echo '    }' >&2
        echo ' ' >&2
        exit 1
    fi

    mkdir "$TMP"
    cd "$TMP"
}

cleanup() {
    cd /
    rm -rf "$TMP"
}

parse_arguments() {
    local arg param value

    for arg in "$@"; do
        if [[ "$arg" =~ ^--.+?=.+$ ]]; then
            arg="${arg:2}"                                      # Strip off leading '--'
            param="${arg%%=*}"                                  # Extract name
            value="${arg#*=}"                                   # Extract value
            param="$(sed -E s/[^a-zA-Z0-9]+/_/g <<< "$param")"  # Replace non alphanumeric chars by underscore
            param="${param^^}"                                  # To upper case
            eval "__$param='$value'"
            eval "echo __$param = \$__$param"
        fi
    done

    echo "--------------------------------"
}

provision() {
    prepare_provision

    # Execute the command
    eval "$@" >"$SHM_STDOUT" 2>"$SHM_STDERR" || stop_provision $? "$@"

    cleanup_provision
}

prepare_provision() {
    rm -f "$SHM_STDOUT" "$SHM_STDERR"
}

cleanup_provision() {
    rm -f "$SHM_STDOUT" "$SHM_STDERR"
}

stop_provision() {
    local code="$1"
    shift

    # Quote args including whitespaces
    for arg in "$@"; do
        if [[ "$arg" =~ ' ' ]]; then
            arg="\"$arg\""
        fi
        cmd="${cmd}${arg} "
    done

    error -q ' '
    error -q ' '
    error "The command terminated with a non-zero exit status."
    error -q ' '
    error -q 'COMMAND was:'
    error -q "  $cmd"
    error -q ' '
    error -q "STDOUT of the command:"
    cat "$SHM_STDOUT" | awk '{print "  >  " $0}' >&2
    error -q ' '

    error -q "STDERR of the command:"
    cat "$SHM_STDERR" | awk '{print "  !  " $0}' >&2
    error -q ' '

    cleanup_provision
    stop "$code"
}

task() {
    local msg="$@"
    echo "# ${msg}"
}

subtask() {
    local msg="$@"
    echo "  - ${msg}"
}

subtask2() {
    local msg="$@"
    echo "    - ${msg}"
}

error() {
    local msg prepend

    [ "$1" != '-q' ] \
        && prepend='Error: ' \
        || shift

    msg="$@"

    echo "${prepend}${msg}" >&2
}

stop() {
    local code=0
    local err=''

    if [[ "$1" =~ ^[0-9]+$ ]] && [ "$1" -le '255' ]; then
        code="$1"
        shift
    fi

    err="$@"

    cleanup

    [ ! -z "$err" ] && error "$err"

    exit "$code"
}

parse_arguments "$@"
prepare
main
echo ' '
echo 'Done :)'
cleanup
